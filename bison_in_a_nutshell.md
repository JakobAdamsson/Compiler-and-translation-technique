# General + Syntax 
Bison is a parser generatior. It is to parsers what flex is to scanners(important :) ).  They work by being provided the input of a grammar specification and it generats an LALR parser to recognize sentences in the grammar.

### How it works:
The parser is configured for use in conjuction with a flex-generated scanner and relies on standard shared features(token types, **yylval**, etc) and calls the function **yylex()** as a scanner coroutine. They are recognized by the **.y** file extention and it creates a **y.tab.h** and a **y.tab.c** file. The file provides an extern function called **yyparse.y** that will attempt to succecfully parse a valid sentence

### The format of a bison file:
```
%{
Declarations
%}

Definitions

%%
Productions
%%

User subroutines
```

### Few things worth pointing out:
All token types from the scanner myst be defined using **%token** in the definitions section.  

For each rule, a colon is used in place of the arrow, a vertical bar(**|**) seperates the various productions, and a semocolon terminates the role. Bison pays no attention to line boinderies in the rules section, so you are free to use lots of space to make grammar look pretty :)

Within the braces theres just simply ordinary C code

**yyparse** is the function generated by Bison. IT reads from **STDIN**. The **yyparse** returns 0 of the parse was successfull and 1 otherwise. If it encounters an error(i.e the next token in the input stream cannot be shifted), it calls the routine **yyerror()**, which by default prints **parse error** and quits.

### How to intepret the Production section.
```
left_side: right_side1 { action1 }
    | right_side2 { action2 }
    | right_side3 { action3 }   
    ;
```
Left side is named typically like identifiers using a sequence of letters and/or digits, starting with a letter. The left side is non-terminal which means that they do not have to be defined before use, but eventually. 

Each right side is a valid expansion for the left side non-terminal.